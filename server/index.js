import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import { createServer } from 'http';
import { Server } from 'socket.io';
import commandRoutes from './routes/commands.js';
import statsRoutes from './routes/stats.js';
import authRoutes from './routes/auth.js';
import userRoutes from './routes/users.js';
import clientRoutes from './routes/clients.js';
import invitationRoutes from './routes/invitations.js';
import organisationRoutes from './routes/organisation.js';
import protect from './middleware/auth.js';
import { setIO } from './utils/socketEvents.js';

dotenv.config();

// V√©rifier que JWT_SECRET est d√©fini
if (!process.env.JWT_SECRET) {
  console.warn('‚ö†Ô∏è JWT_SECRET non d√©fini, utilisation d\'une valeur par d√©faut (INS√âCURIS√â)');
  process.env.JWT_SECRET = 'default-secret-key-change-in-production';
}

const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: [
      "http://localhost:5173", 
      "http://localhost:3000", 
      "http://192.168.1.98:5173",
      "http://77.129.48.8:5173",
      "http://77.129.48.8:3000"
    ],
    methods: ["GET", "POST"]
  }
});

// Initialiser Socket.IO dans l'utilitaire
setIO(io);

const PORT = 5001;

// Middleware
app.use(cors());
app.use(express.json());

// Socket.IO connection handling
io.on('connection', (socket) => {
  console.log('üîå Nouveau client connect√©:', socket.id);

  // Authentifier le socket et r√©cup√©rer l'organisation
  socket.on('authenticate', async (data) => {
    try {
      console.log('üîê Tentative d\'authentification socket pour:', socket.id);
      const { token } = data;
      if (!token) {
        console.log('‚ùå Token manquant pour socket:', socket.id);
        socket.emit('auth_error', { message: 'Token manquant' });
        return;
      }

      console.log('üîê Token re√ßu, longueur:', token.length);
      
      // V√©rifier le token et r√©cup√©rer l'utilisateur
      console.log('üîê V√©rification du token avec JWT_SECRET...');
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      console.log('üîê Token d√©cod√©, userId:', decoded.userId);
      
      // R√©cup√©rer l'utilisateur avec son organisation
      const User = (await import('./models/User.js')).default;
      const user = await User.findById(decoded.userId).populate('organisation');
      
      if (!user) {
        console.log('‚ùå Utilisateur non trouv√© pour userId:', decoded.userId);
        socket.emit('auth_error', { message: 'Utilisateur non trouv√©' });
        return;
      }
      
      if (!user.organisation) {
        console.log('‚ùå Organisation non trouv√©e pour utilisateur:', user.email);
        socket.emit('auth_error', { message: 'Organisation non trouv√©e' });
        return;
      }

      console.log('‚úÖ Utilisateur et organisation trouv√©s:', user.email, '->', user.organisation.nom);

      // Stocker les informations de l'utilisateur dans le socket
      socket.userId = user._id;
      socket.organisationId = user.organisation._id;
      socket.organisationName = user.organisation.nom;

      // Rejoindre la room sp√©cifique √† l'organisation
      const organisationRoom = `organisation_${user.organisation._id}`;
      socket.join(organisationRoom);
      
      console.log(`üîå Client ${socket.id} authentifi√© et rejoint la room ${organisationRoom} (${user.organisation.nom})`);
      
      socket.emit('authenticated', { 
        message: 'Authentifi√© avec succ√®s',
        organisation: user.organisation.nom
      });

    } catch (error) {
      console.error('‚ùå Erreur d√©taill√©e d\'authentification socket:', error);
      console.error('‚ùå Stack trace:', error.stack);
      socket.emit('auth_error', { message: 'Erreur d\'authentification: ' + error.message });
    }
  });

  // Connexion publique pour les pages mobiles (sans authentification)
  socket.on('join_public', async (data) => {
    try {
      const { commandId } = data;
      if (!commandId) {
        socket.emit('public_error', { message: 'CommandId manquant' });
        return;
      }

      console.log('üì± Page mobile publique connect√©e pour commande:', commandId);
      
      // Rejoindre une room publique pour cette commande
      const publicRoom = `public_command_${commandId}`;
      socket.join(publicRoom);
      
      // Stocker l'info pour les logs
      socket.publicCommandId = commandId;
      
      console.log(`üì± Client public ${socket.id} rejoint la room ${publicRoom}`);
      
      socket.emit('public_joined', { 
        message: 'Connect√© en mode public',
        commandId: commandId
      });

    } catch (error) {
      console.error('‚ùå Erreur connexion publique:', error);
      socket.emit('public_error', { message: 'Erreur de connexion publique' });
    }
  });

  // √âcouter les √©v√©nements de la page mobile (seulement si authentifi√©)
  socket.on('STATUS_CHANGED', (data) => {
    if (!socket.organisationId) {
      console.log('‚ö†Ô∏è Tentative d\'√©mission sans authentification:', socket.id);
      return;
    }
    
    console.log(`üì± √âv√©nement STATUS_CHANGED re√ßu de ${socket.organisationName}:`, data);
    // Diffuser l'√©v√©nement uniquement aux clients de la m√™me organisation
    const organisationRoom = `organisation_${socket.organisationId}`;
    socket.to(organisationRoom).emit('STATUS_CHANGED', data);
  });

  socket.on('disconnect', () => {
    console.log(`üîå Client d√©connect√©: ${socket.id} (${socket.organisationName || socket.publicCommandId || 'non authentifi√©'})`);
  });
});

// Fonction utilitaire pour √©mettre des √©v√©nements de mise √† jour
export const emitCommandUpdate = (eventType, data) => {
  console.log(`üì° √âmission √©v√©nement ${eventType}:`, data);
  io.to('commands').emit(eventType, data);
};

// Routes
// Routes publiques
app.use('/api/auth', authRoutes);

// Route publique pour mise √† jour rapide du statut
app.put('/api/commands/:id/quick-status', async (req, res) => {
  try {
    const { statut, progression = 0, notifyClient = false } = req.body;
    
    console.log('Mise √† jour rapide statut:', { 
      commandId: req.params.id, 
      statut, 
      progression, 
      notifyClient 
    });
    
    if (!statut) {
      return res.status(400).json({ error: 'Statut requis' });
    }

    // Chercher la commande dans toutes les organisations par commandId ou _id
    const Organisation = (await import('./models/Organisation.js')).default;
    let organisation = null;
    let command = null;
    let commandIndex = -1;

    // D'abord essayer de trouver par commandId (nouvelle structure)
    const organisations = await Organisation.find({
      'commandes.commandId': parseInt(req.params.id)
    }).populate('commandes.etapesProduction.responsable', 'nom')
      .populate('commandes.clientId');

    if (organisations.length > 0) {
      organisation = organisations[0];
      commandIndex = organisation.commandes.findIndex(cmd => cmd.commandId === parseInt(req.params.id));
      if (commandIndex !== -1) {
        command = organisation.commandes[commandIndex];
      }
    }

    // Si pas trouv√© par commandId, essayer par _id (ancienne structure)
    if (!command) {
      const organisationsById = await Organisation.find({
        'commandes._id': req.params.id
      }).populate('commandes.etapesProduction.responsable', 'nom')
        .populate('commandes.clientId');

      if (organisationsById.length > 0) {
        organisation = organisationsById[0];
        commandIndex = organisation.commandes.findIndex(cmd => cmd._id.toString() === req.params.id);
        if (commandIndex !== -1) {
          command = organisation.commandes[commandIndex];
        }
      }
    }

    if (!command) {
      return res.status(404).json({ error: 'Commande non trouv√©e' });
    }

    const previousStatus = command.statut;
    console.log('Ancien statut:', previousStatus);

    // Recalculer la progression comme dans la route web
    let newProgression = progression;
    if (["ready", "shipped", "delivered"].includes(statut)) {
      newProgression = 100;
    } else {
      // Recalculer la progression selon les √©tapes termin√©es
      if (command.etapesProduction && command.etapesProduction.length > 0) {
        const completedSteps = command.etapesProduction.filter(e => e.statut === 'completed').length;
        newProgression = Math.round((completedSteps / command.etapesProduction.length) * 100);
      } else {
        newProgression = 0;
      }
    }

    // Mettre √† jour la commande dans l'organisation
    organisation.commandes[commandIndex].statut = statut;
    organisation.commandes[commandIndex].progression = newProgression;
    organisation.commandes[commandIndex].lastModifiedBy = 'mobile-operator';
    organisation.commandes[commandIndex].lastModifiedAt = new Date();

    await organisation.save();

    const updatedCommand = organisation.commandes[commandIndex];
    console.log('Commande mise √† jour:', updatedCommand.numero);

    // Envoyer un email au client si demand√©
    let emailSent = false;
    if (notifyClient) {
      try {
        if (updatedCommand.clientId && updatedCommand.clientId.email) {
          console.log('Tentative d\'envoi d\'email √†:', updatedCommand.clientId.email);
          const sendStatusUpdateMail = (await import('./utils/sendStatusUpdateMail.js')).default;
          await sendStatusUpdateMail(updatedCommand, statut);
          console.log(`Email de notification envoy√© au client ${updatedCommand.clientId.email} pour la commande ${updatedCommand.numero}`);
          emailSent = true;
        } else {
          console.log('Aucun email √† envoyer - client sans email');
        }
      } catch (emailError) {
        console.error('Erreur lors de l\'envoi de l\'email (non critique):', emailError.message);
      }
    } else {
      console.log('Aucun email demand√©');
    }

    // Cr√©er une entr√©e dans l'historique (apr√®s l'envoi du mail)
    try {
      const History = (await import('./models/History.js')).default;
      const historyEntry = new History({
        user: null,
        action: 'UPDATE_STATUS',
        entity: 'Command',
        entityId: updatedCommand._id,
        changes: {
          previousStatus: previousStatus,
          newStatus: statut,
          progression: newProgression
        },
        source: 'mobile',
        timestamp: new Date(),
        mailSent: emailSent,
      });
      await historyEntry.save();
      console.log('Historique cr√©√© avec succ√®s');
    } catch (historyError) {
      console.log('Erreur lors de la cr√©ation de l\'historique (non critique):', historyError.message);
    }

    console.log('Envoi de la r√©ponse au client');
    
    // √âmettre l'√©v√©nement Socket.IO pour la synchronisation en temps r√©el
    console.log('[SOCKET][COMMAND_FULLY_UPDATED][QUICK] CommandId:', updatedCommand._id, '| Statut:', statut, '| Progression envoy√©e:', updatedCommand.progression);
    
    const { emitCommandFullyUpdated } = await import('./utils/socketEvents.js');
    emitCommandFullyUpdated(updatedCommand, organisation._id);
    
    res.json({ 
      success: true, 
      message: 'Statut mis √† jour avec succ√®s',
      emailSent: emailSent,
      command: {
        _id: updatedCommand._id,
        commandId: updatedCommand.commandId,
        numero: updatedCommand.numero,
        statut: updatedCommand.statut,
        progression: updatedCommand.progression
      }
    });
  } catch (error) {
    console.error('Erreur mise √† jour rapide statut:', error);
    console.error('Stack trace:', error.stack);
    res.status(500).json({ 
      error: 'Erreur lors de la mise √† jour du statut',
      details: error.message 
    });
  }
});

// Route publique pour r√©cup√©rer les d√©tails d'une commande (pour la page mobile)
app.get('/api/commands/:id/quick-view', async (req, res) => {
  try {
    // Chercher la commande dans toutes les organisations par commandId ou _id
    const Organisation = (await import('./models/Organisation.js')).default;
    let command = null;

    // D'abord essayer de trouver par commandId (nouvelle structure)
    const organisations = await Organisation.find({
      'commandes.commandId': parseInt(req.params.id)
    }).populate('commandes.etapesProduction.responsable', 'nom')
      .populate('commandes.clientId');

    if (organisations.length > 0) {
      command = organisations[0].commandes.find(cmd => cmd.commandId === parseInt(req.params.id));
    }

    // Si pas trouv√© par commandId, essayer par _id (ancienne structure)
    if (!command) {
      const organisationsById = await Organisation.find({
        'commandes._id': req.params.id
      }).populate('commandes.etapesProduction.responsable', 'nom')
        .populate('commandes.clientId');

      if (organisationsById.length > 0) {
        command = organisationsById[0].commandes.find(cmd => cmd._id.toString() === req.params.id);
      }
    }

    if (!command) {
      return res.status(404).json({ error: 'Commande non trouv√©e' });
    }

    res.json(command);
  } catch (error) {
    console.error('Erreur r√©cup√©ration commande:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration de la commande' });
  }
});

// Routes prot√©g√©es
app.use('/api/commands', protect, commandRoutes);
app.use('/api/stats', protect, statsRoutes);
app.use('/api/users', protect, userRoutes);
app.use('/api/clients', protect, clientRoutes);
app.use('/api/invitations', invitationRoutes);
app.use('/api/organisation', protect, organisationRoutes);

// MongoDB Connection
const connectDB = async () => {
  try {
    if (!process.env.MONGODB_URI) {
      console.error('‚ùå MONGODB_URI n\'est pas d√©fini dans le fichier .env');
      console.log('üìù Veuillez cr√©er un fichier .env avec votre cha√Æne de connexion MongoDB Atlas');
      console.log('   Format: MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/production-tracking');
      process.exit(1);
    }

    await mongoose.connect(process.env.MONGODB_URI);
    console.log('‚úÖ Connect√© √† MongoDB Atlas');
  } catch (error) {
    console.error('‚ùå Erreur de connexion √† MongoDB:', error.message);
    console.log('üí° V√©rifiez votre cha√Æne de connexion MongoDB Atlas dans le fichier .env');
    process.exit(1);
  }
};

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'API de suivi de production fonctionnelle',
    database: mongoose.connection.readyState === 1 ? 'Connect√©e' : 'D√©connect√©e'
  });
});

app.get('/api', (req, res) => {
  res.json({
    message: "Bienvenue sur l'API ProductionFlow üöÄ",
    endpoints: [
      '/api/health',
      '/api/commands',
      '/api/clients',
      '/api/stats',
      '/api/users',
      '/api/organisation',
      '/api/invitations',
      '/api/auth',
      '/api/commands/:id/quick-status',
      '/api/commands/:id/quick-view',
    ]
  });
});

// Start server
const startServer = async () => {
  await connectDB();
  server.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
    console.log(`üìä API disponible sur http://localhost:${PORT}/api`);
    console.log(`üåê API accessible sur le r√©seau local: http://192.168.1.98:${PORT}/api`);
  });
};

startServer();